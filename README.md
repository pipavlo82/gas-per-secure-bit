# Gas per Secure Bit

<div align="center">

**Benchmarking post-quantum signatures and verifiable randomness on EVM by gas cost per cryptographically meaningful bit.**

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Built with Foundry](https://img.shields.io/badge/Built%20with-Foundry-FFDB1C.svg)](https://getfoundry.sh/)

</div>

---

This repository is an experimental benchmarking lab spun out of  
[`ml-dsa-65-ethereum-verification`](https://github.com/pipavlo82/ml-dsa-65-ethereum-verification).

It exists to answer one practical question for Ethereum engineers:

> **How expensive is "real security" on EVM — once you normalize gas by a declared security target and by protocol constraints?**

In other words: **"gas/verify" is not enough** if the protocol envelope bounds end-to-end security even when the wallet uses PQ signatures.

---

## Core Metric

GitHub does **not** render LaTeX by default, so the canonical formula is written in plain form:

> **gas_per_bit = gas_verify / security_metric_value**

Where:
- **gas_verify** — on-chain gas used to verify a signature / proof (or a verifiable computation step).
- **security_metric_type** — what the denominator represents:
  - for **signatures / proofs (today)**: `security_equiv_bits` (a declared *classical-equivalent bits* normalization convention)
  - for **randomness / VRF (future)**: `H_min` (min-entropy of the verified output under an explicit threat model)
- **security_metric_value** — the denominator value in bits.

For the current signature-only dataset, we typically report:

> **gas_per_secure_bit = gas_verify / security_equiv_bits**

This allows apples-to-apples comparisons across schemes at different security targets, **under explicit assumptions**.

---

## Public Review Entry Points

If you have 10 minutes:
1. `reports/protocol_readiness.md` — protocol constraints and why "gas/verify" can be misleading.
2. `spec/case_catalog.md` + `spec/case_graph.md` — AA weakest-link (envelope dominance) cases + canonical graphs.
3. `spec/gas_per_secure_bit.md` — definitions, normalization rules, reporting conventions.
4. `data/results.csv` — source-of-truth dataset; charts are derived from it.

---

## Why This Exists

Most public comparisons stop at "gas per verify". That hides critical differences:

- Different security levels (e.g., ECDSA ~128-bit convention vs ML-DSA-65 ~192 vs Falcon-1024 ~256)
- Different verification surfaces (EOA vs ERC-1271 vs EIP-4337 pipeline)
- Different protocol envelopes (e.g., L1 constraints can bound end-to-end security regardless of wallet scheme)

This repo focuses on:
- **normalized units** (gas per declared security-equivalent bit), and
- **protocol-aware interpretation** (weakest-link / envelope dominance).

---

## Chart

![Gas per secure bit (lower is better)](docs/gas_per_secure_bit_big.svg)

(Full-detail chart: [docs/gas_per_secure_bit.svg](docs/gas_per_secure_bit.svg))

> **NOTE:** Charts are derived from `data/results.csv`. If you change normalization conventions (e.g., ML-DSA-65 128 → 192), regenerate charts from the updated CSV.

---

## Current Dataset (EVM/L1) — Gas Snapshots

**Source of truth:** `data/results.csv` (generated by `scripts/run_vendor_*.sh` + `scripts/parse_bench.py`).

| Scheme        | Bench name                                | gas_verify  | security_equiv_bits | gas / secure-bit |
|---------------|-------------------------------------------|------------:|--------------------:|-----------------:|
| **ECDSA**     | ecdsa_verify_ecrecover_foundry            | 21,126      | 128                 | 165.047          |
| **ECDSA**     | ecdsa_erc1271_isValidSignature_foundry    | 21,413      | 128                 | 167.289          |
| **ECDSA**     | ecdsa_verify_bytes65_foundry              | 24,032      | 128                 | 187.750          |
| **Falcon**    | qa_getUserOpHash_foundry                  | 218,333     | 256                 | 852.863          |
| **ML-DSA-65** | preA_compute_w_fromPackedA_ntt_rho0_log   | 1,499,354   | 192                 | 7,809.135        |
| **ML-DSA-65** | preA_compute_w_fromPackedA_ntt_rho1_log   | 1,499,354   | 192                 | 7,809.135        |
| **Falcon**    | falcon_verifySignature_log                | 10,336,055  | 256                 | 40,375.215       |
| **Falcon**    | qa_validateUserOp_userop_log              | 10,589,132  | 256                 | 41,363.797       |
| **Falcon**    | qa_handleOps_userop_foundry               | 10,966,076  | 256                 | 42,836.234       |
| **ML-DSA-65** | verify_poc_foundry                        | 68,901,612  | 192                 | 358,862.563      |

**Notes:**
- `qa_handleOps_userop_foundry` includes the full EIP-4337 pipeline (`EntryPoint.handleOps`), so it is **not** a "pure signature verify" cost.
- `falcon_verifySignature_log` is a **clean verifySignature-only** microbench extracted from QuantumAccount logs.
- `verify_poc_foundry` for ML-DSA-65 is a full decode + checks + `w = A*z − c*t1` POC (FIPS-204 shape), built for correctness + reproducibility.

---

## What We Built (So Far)

A reproducible benchmark lab with:

### 1) Dataset + Schema
- Canonical dataset files:
  - `data/results.jsonl`
  - `data/results.csv`
- Canonical schema/spec documents under `spec/`
- `scripts/parse_bench.py` generates CSV rows and computed `gas_per_secure_bit`.

### 2) Runners (Reproducible Ingestion)
- `scripts/run_vendor_mldsa.sh` — vendored runner for ML-DSA-65 (Foundry gas + log extraction for PreA rho0/rho1).
- `scripts/run_vendor_quantumaccount.sh` — vendored runner for QuantumAccount (Falcon) benches + log-based gas extraction.
- `scripts/run_ecdsa.sh` — ECDSA baselines (ecrecover, bytes65 wrapper, ERC-1271).

### 3) Baseline Benches (ECDSA)
- `ecrecover` verify gas
- bytes65 wrapper
- ERC-1271 `isValidSignature`

### 4) ML-DSA-65 (FIPS-204 shape)
Benchmarks currently tracked:
- `verify_poc_foundry` — full POC verify path for correctness + gas snapshot.
- `preA_compute_w_fromPackedA_ntt_rho{0,1}_log` — compute_w microbench from packed `A_ntt` (PreA path).

### 5) Falcon / QuantumAccount (AA-oriented)
Benchmarks ingested:
- AA helper / pipeline benches (`getUserOpHash`, `handleOps`, `validateUserOp`)
- plus a clean `Falcon.verifySignature` microbench extracted from logs.

We also keep an in-repo copy of a Falcon microbench:
- `bench/falcon/Falcon_GasMicro.t.sol`

### 6) Protocol Interpretation Layer
- **Weakest-link / envelope dominance** case catalog and canonical graphs:
  - `spec/case_catalog.md`
  - `spec/case_graph.md`
- **Protocol readiness narrative** tying together:
  - weakest-link results, and
  - entropy/attestation "surfaces" framing:
  - `reports/protocol_readiness.md`

---

## Repo Layout

- `bench/` — microbench contracts/tests for local measurement
- `scripts/` — runners + parsers
- `data/` — dataset outputs (CSV/JSONL)
- `docs/` — charts (SVG) derived from dataset
- `spec/` — definitions, methodology, case catalog, schema notes
- `reports/` — narrative reports connecting results to protocol constraints

Vendor clones live under `vendors/` (gitignored). Provenance is recorded per row in the dataset.

---

## Dataset Schema (CSV)

Canonical format: `data/results.csv`

Columns:
- `ts_utc` — timestamp UTC
- `repo`, `commit` — provenance of the implementation
- `scheme` — e.g., `mldsa65`, `ecdsa`, `falcon1024`
- `bench_name` — benchmark identifier
- `chain_profile` — e.g., `EVM/L1` (extendable to L2 profiles)
- `gas_verify` — gas used for the bench
- `security_metric_type` — e.g., `security_equiv_bits` (signatures) or `H_min` (randomness/VRF)
- `security_metric_value` — metric value in bits (e.g., 128 / 192 / 256)
- `gas_per_secure_bit` — computed as `gas_verify / security_metric_value`
- `hash_profile` — e.g., `keccak256` or `unknown`
- `notes` — context + refs (runner, branch, extraction method)

Right now (signature dataset) we primarily use:
- `security_metric_type = security_equiv_bits`
- `security_metric_value ∈ {128.0, 192.0, 256.0}`

This will evolve to support VRF/randomness objects where the denominator is `H_min` (min-entropy), not just security-equivalent bits.

---

## Security Normalization (Explicit Assumptions)

This repo separates:
1. A scheme's **security category** (when applicable), and
2. A declared **security-equivalent bits** normalization value used for comparisons: `security_equiv_bits`.

### Current Working Convention (Signatures; Normalization Only)

| Scheme | Security Category | `security_equiv_bits` | Notes |
|--------|-------------------|----------------------|-------|
| **ECDSA (secp256k1)** | - | 128 | classical security convention |
| **ML-DSA-65 (FIPS-204)** | Category 3 | 192 | classical-equivalent convention |
| **Falcon-1024** | Category 5 | 256 | classical-equivalent convention |

**Important:** These are normalization conventions, not security proofs. The rule is that they are explicit and applied consistently.

### Optional Baseline Normalization (Separate Metric)

If you want "per 128-bit baseline" as a convenience view:

```
gas_per_128b = gas_verify / 128
```

Label it explicitly as baseline (not "secure-bit").

---

## Quick Start

### Prerequisites
- Linux/WSL recommended
- `git`
- **Foundry** (`forge`)
- Python 3

### Build a Fresh Dataset (ML-DSA + ECDSA + Falcon)

From repo root:

```bash
cd /mnt/c/Users/msi/gas-per-secure-bit

: > data/results.jsonl
: > data/results.csv

# ML-DSA (rows)
RESET_DATA=0 MLDSA_REF="feature/mldsa-ntt-opt-phase12-erc7913-packedA" ./scripts/run_vendor_mldsa.sh

# ECDSA (rows)
RESET_DATA=0 ./scripts/run_ecdsa.sh

# QuantumAccount/Falcon (rows)
QA_REF=main RESET_DATA=0 ./scripts/run_vendor_quantumaccount.sh

wc -l data/results.jsonl data/results.csv
tail -n 20 data/results.csv
```

### Sanity Check: Ensure Benches Are Unique

```bash
cut -d, -f4,5 data/results.csv | tail -n +2 | sort | uniq -c
```

### Summary View (Sorted by gas/bit)

```bash
python3 - <<'PY'
import csv
rows=list(csv.DictReader(open("data/results.csv")))
rows.sort(key=lambda r: float(r["gas_per_secure_bit"]))
for r in rows:
    print(f'{r["scheme"]:10s} {r["bench_name"]:38s} gas={int(r["gas_verify"]):>9,d}  gas/bit={float(r["gas_per_secure_bit"]):>12,.3f}')
PY
```

---

## Benchmarks Included

### ML-DSA-65 (FIPS-204 shape)
- `verify_poc_foundry` — full decode + checks + w = A*z − c*t1 verify POC
- `preA_compute_w_fromPackedA_ntt_rho{0,1}_log` — compute_w microbench from packed A_ntt (PreA path)

### ECDSA (bench/ecdsa)
- `ecdsa_verify_ecrecover_foundry`
- `ecdsa_verify_bytes65_foundry`
- `ecdsa_erc1271_isValidSignature_foundry`

### Falcon / QuantumAccount (vendor + local copy)
Ingested benches:
- `qa_getUserOpHash_foundry` — EntryPoint helper
- `qa_handleOps_userop_foundry` — end-to-end AA pipeline
- `qa_validateUserOp_userop_log` — account validation path (log-based gas)
- `falcon_verifySignature_log` — clean verifySignature-only microbench (log-based gas)

Local microbench copy:
- `bench/falcon/Falcon_GasMicro.t.sol`

---

## Related Work / References

### PQ Signatures on EVM
- **NIST FIPS-204 (ML-DSA):** https://csrc.nist.gov/pubs/fips/204/final
- **ZKNoxHQ:**
  - **ETHFALCON:** https://github.com/ZKNoxHQ/ETHFALCON
  - **ETHDILITHIUM:** https://github.com/ZKNoxHQ/ETHDILITHIUM
- **Paul Angus** (Falcon discussions):
  - EthResearch profile: https://ethresear.ch/u/paulangusbark
  - Falcon reference site: https://falcon-sign.info

### Account Abstraction / Wallet Interfaces Used in Benches
- **EIP-4337** (EntryPoint / AA): https://eips.ethereum.org/EIPS/eip-4337
- **EIP-1271** (contract wallet signatures): https://eips.ethereum.org/EIPS/eip-1271

### Vendor Benchmark Sources
- **QuantumAccount** (Falcon1024 AA stack): https://github.com/Cointrol-Limited/QuantumAccount

### Tooling
- **Foundry:** https://getfoundry.sh/

---

## Roadmap

### Near-term
- Harden spec text in `spec/gas_per_secure_bit.md` (definitions, assumptions, reporting rules).
- Add more schemes: Dilithium, BLS, other PQ candidates relevant to EVM.
- Expand "weakest-link" catalog with more protocol cases and explicit attacker models.

### Medium-term
- Add VRF / randomness objects with explicit `H_min` denominators under stated trust models.
- Add L2 profiles (`chain_profile`) and standardize reporting across L1/L2.

### Standardization Track
Converge dataset schema + methodology into a draft spec others can reuse:
- reproducible runners,
- canonical case catalog,
- comparable benchmark definitions,
- explicit security normalization rules.

---

## License

See `LICENSE` (and vendor repo licenses where applicable). This repository records benchmark artifacts and provenance; vendor code remains licensed by upstream.

---

## Disclaimer

This is an experimental benchmarking lab. Results are not a security proof. Use the data as comparative engineering evidence under explicitly stated assumptions.

---

## Maintainer

Maintained by Pavlo Tvardovskyi (GitHub: @pipavlo82)  
Contact: shtomko@gmail.com

---

## Citation

If you use this repository (methodology, dataset schema, runners, or benchmarks) in research or production evaluation, please cite it as:

```
Pavlo Tvardovskyi, gas-per-secure-bit (GitHub repository), YYYY.
https://github.com/pipavlo82/gas-per-secure-bit
```

For reproducibility, cite a tag or commit hash.
