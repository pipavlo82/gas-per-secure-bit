# Gas per secure bit

<div align="center">

<!-- Optional: keep this image if you have it -->
<img src="./docs/formula.png" alt="Gas per secure bit formula" width="320"/>

**Benchmarking post-quantum signatures and verifiable randomness by gas cost per cryptographically secure bit.**

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Built with Foundry](https://img.shields.io/badge/Built%20with-Foundry-FFDB1C.svg)](https://getfoundry.sh/)

</div>

---

This repository is an experimental lab spun out of  
[`ml-dsa-65-ethereum-verification`](https://github.com/pipavlo82/ml-dsa-65-ethereum-verification).  
Here we are free to break, refactor, and experiment without touching the original verifier repo.

---

## Core metric

GitHub does **not** render LaTeX by default, so the canonical formula is written in plain form:

> **gas_per_secure_bit = gas_verify / lambda_eff**

Where:
- **gas_verify** — on-chain gas used to verify a signature / proof (or a verifiable computation step).
- **lambda_eff** — effective security level in bits:
  - for **signatures**: effective security level (e.g., 128-bit, 256-bit),
  - for **randomness / VRF**: min-entropy of the **verified** output under an explicit threat model.

This lets us compare schemes not just by “gas per verify”, but by **gas per actual cryptographic security / entropy**.

---

## Why this exists

Most public comparisons stop at “gas per verify”. That hides the real tradeoff:
- a 20k-gas ECDSA verify (≈128-bit security) is not directly comparable to
- a 10M-gas Falcon verify (≈256-bit security), or
- a VRF check with a different trust / entropy model.

This repo focuses on a normalized unit: **gas / secure-bit**, with explicit assumptions.

---
![Gas per secure bit (lower is better)](docs/gas_per_secure_bit_big.svg)

(Full-detail chart: [docs/gas_per_secure_bit.svg](docs/gas_per_secure_bit.svg))


## Gas snapshots (EVM/L1) — current dataset

**Source of truth:** `data/results.csv` (generated by `scripts/run_vendor_*.sh` + `scripts/parse_bench.py`).

| Scheme        | Bench name                                | gas_verify  | security_equiv_bits | gas / secure-bit |
|---------------|-------------------------------------------|------------:|--------------------:|-----------------:|
| **ECDSA**     | ecdsa_verify_ecrecover_foundry            | 21,126      | 128                 | 165.047          |
| **ECDSA**     | ecdsa_erc1271_isValidSignature_foundry    | 21,413      | 128                 | 167.289          |
| **ECDSA**     | ecdsa_verify_bytes65_foundry              | 24,032      | 128                 | 187.750          |
| **Falcon**    | qa_getUserOpHash_foundry                  | 218,333     | 256                 | 852.863          |
| **ML-DSA-65** | preA_compute_w_fromPackedA_ntt_rho0_log   | 1,499,354   | 192                 | 7,809.135        |
| **ML-DSA-65** | preA_compute_w_fromPackedA_ntt_rho1_log   | 1,499,354   | 192                 | 7,809.135        |
| **Falcon**    | falcon_verifySignature_log                | 10,336,055  | 256                 | 40,375.215       |
| **Falcon**    | qa_validateUserOp_userop_log              | 10,589,132  | 256                 | 41,363.797       |
| **Falcon**    | qa_handleOps_userop_foundry               | 10,966,076  | 256                 | 42,836.234       |
| **ML-DSA-65** | verify_poc_foundry                        | 68,901,612  | 192                 | 358,862.563      |

**Notes:**
- `qa_handleOps_userop_foundry` includes the full EIP-4337 pipeline (`EntryPoint.handleOps`), so it is **not** a “pure signature verify” cost.
- `falcon_verifySignature_log` is a **clean verifySignature-only** microbench extracted from QuantumAccount logs.

---

## What’s in the repo today

A working, reproducible dataset with:
- **ML-DSA-65 (FIPS-204 shape)** — verify POC + PreA `compute_w` microbench (packed A_ntt path).
- **ECDSA baselines** — `ecrecover`, bytes65 wrapper, ERC-1271 `isValidSignature`.
- **Falcon (QuantumAccount)** — AA-related benches + clean `Falcon.verifySignature` microbench.

Outputs are stored in:
- `data/results.jsonl`
- `data/results.csv`

---

## Dataset schema (CSV)

Canonical format: `data/results.csv`

Columns:
- `ts_utc` — timestamp UTC
- `repo`, `commit` — provenance of the implementation
- `scheme` — e.g., `mldsa65`, `ecdsa`, `falcon1024`
- `bench_name` — benchmark identifier
- `chain_profile` — e.g., `EVM/L1` (extendable to L2 profiles)
- `gas_verify` — gas used for the bench
- `security_metric_type` — currently `lambda_eff`
- `security_metric_value` — currently `lambda_eff` in bits
- `gas_per_secure_bit` — computed `gas_verify / security_metric_value`
- `hash_profile` — e.g., `keccak256` or `unknown`
- `notes` — context + refs (and runner branch refs)

Right now we primarily use:
- `security_metric_type = lambda_eff`
- `security_metric_value ∈ {128.0, 256.0}`

This will evolve to support VRF/randomness objects where the denominator is `H_min`, not just `lambda`.

---

## Quick start

### Prerequisites
- Linux/WSL recommended
- `git`
- **Foundry** (`forge`)
- Python 3

### Build a fresh dataset (ML-DSA + ECDSA + Falcon)

From repo root:
```bash
cd /mnt/c/Users/msi/gas-per-secure-bit

: > data/results.jsonl
: > data/results.csv

# ML-DSA (3 rows)
RESET_DATA=0 MLDSA_REF="feature/mldsa-ntt-opt-phase12-erc7913-packedA" ./scripts/run_vendor_mldsa.sh

# ECDSA (3 rows)
RESET_DATA=0 ./scripts/run_ecdsa.sh

# QuantumAccount/Falcon (4 rows)
QA_REF=main RESET_DATA=0 ./scripts/run_vendor_quantumaccount.sh

wc -l data/results.jsonl data/results.csv
tail -n 20 data/results.csv
```

### Sanity check: ensure benches are unique
```bash
cut -d, -f4,5 data/results.csv | tail -n +2 | sort | uniq -c
```

### Summary view (sorted by gas/secure-bit)
```bash
python3 - <<'PY'
import csv
rows=list(csv.DictReader(open("data/results.csv")))
rows.sort(key=lambda r: float(r["gas_per_secure_bit"]))
for r in rows:
    print(f'{r["scheme"]:10s} {r["bench_name"]:38s} gas={int(r["gas_verify"]):>9,d}  gas/bit={float(r["gas_per_secure_bit"]):>12,.3f}')
PY
```

---

## Benchmarks included

### ML-DSA-65 (FIPS-204 shape)
- `verify_poc_foundry` — full decode + checks + `w = A*z − c*t1` verify POC
- `preA_compute_w_fromPackedA_ntt_rho{0,1}_log` — microbench of compute_w from packed `A_ntt` (PreA path)

ML-DSA vendor runner pulls from `ml-dsa-65-ethereum-verification` at `MLDSA_REF` and records `repo/commit` provenance.

### ECDSA (`bench/ecdsa`)
- `ecdsa_verify_ecrecover_foundry`
- `ecdsa_verify_bytes65_foundry`
- `ecdsa_erc1271_isValidSignature_foundry`

### Falcon / QuantumAccount (vendor + local copy)
Runner records:
- `qa_getUserOpHash_foundry` — EntryPoint helper
- `qa_handleOps_userop_foundry` — end-to-end AA pipeline
- `qa_validateUserOp_userop_log` — account validation path (log-based gas)
- `falcon_verifySignature_log` — clean Falcon verifySignature-only microbench (log-based gas)

We also keep a copy of the Falcon microbench tracked in-repo:
- `bench/falcon/Falcon_GasMicro.t.sol`

Vendor clones live under `vendors/` (gitignored).

---

## Threat model notes (current)

Today, `lambda_eff` is treated as:
- **ECDSA**: `lambda_eff ≈ 128` (classical security)
- **ML-DSA-65**: `lambda_eff ≈ 128` (post-quantum target for ML-DSA-65 category)
- **Falcon-1024**: `lambda_eff ≈ 256` (post-quantum target for Falcon-1024 category)

This repo is explicit that the security metric is a **field**, not a constant.

---

## Related work / references

### PQ signatures on EVM
- **NIST FIPS-204 (ML-DSA)**: https://csrc.nist.gov/pubs/fips/204/final
- **ZKNoxHQ**:
  - ETHFALCON: https://github.com/ZKNoxHQ/ETHFALCON
  - ETHDILITHIUM: https://github.com/ZKNoxHQ/ETHDILITHIUM
- **Paul Angus** (Falcon on-chain work / discussions):
  - EthResearch profile: https://ethresear.ch/u/paulangusbark
  - Falcon reference site: https://falcon-sign.info

### Account abstraction / wallet interfaces used in benches
- **EIP-4337** (EntryPoint / AA): https://eips.ethereum.org/EIPS/eip-4337
- **EIP-1271** (contract wallet signatures): https://eips.ethereum.org/EIPS/eip-1271

### Vendor benchmark sources
- **QuantumAccount** (Falcon1024 AA stack): https://github.com/Cointrol-Limited/QuantumAccount

### Tooling
- **Foundry**: https://getfoundry.sh/

---

## Roadmap

- Spec hardening: `spec/gas_per_secure_bit.md` (definitions, assumptions, examples, reporting rules).
- More schemes: Dilithium, BLS, other PQ candidates relevant for EVM.
- VRF / randomness: adapters + explicit `H_min` reporting under stated trust models.
- Standardization track: converge dataset schema + methodology into a draft spec others can reuse.

---

## License

See `LICENSE` (and vendor repo licenses where applicable). This repo records benchmark artifacts and provenance; vendor code remains licensed by upstream.

---

## Disclaimer

This is an experimental benchmarking lab. Results are not a security proof. Use the data as comparative engineering evidence under explicitly stated assumptions.
